Forwarded: https://github.com/MariaDB/server/pull/2448
Origin: https://patch-diff.githubusercontent.com/raw/MariaDB/server/pull/2448.patch
From: Daniel Black <daniel@mariadb.org>
Date: Mon, 23 Jan 2023 17:50:53 +1100
Subject: [PATCH] MDEV-30411: main.explain_json_format_partitions fails on
 Debian armel and armhf builders

The my_timer_cycles is an impressive collection of cycle based
timers that isn't comprehensive on all architectures.

MDEV-28926 is such that if there isn't an implementation then the output
doesn't include the r_total_time_ms values and therefore test results
change.

As an alternative to my_timer_cycles, my_timer_interval returns a
clock_gettime based implementation. These on Linux for kernel versions
above about 4.0 are VDSO based implementations on arm, arm64, mips,
powerpc, ppc64le,riscv, x86, x86_64 and a few others. As these results
are returning in nanoseconds, the measure of the time interval is
clearer than a static CPU frequency measure at MariaDB startup.
---
 sql/sql_analyze_stmt.h | 25 ++++++++++++-------------
 1 file changed, 12 insertions(+), 13 deletions(-)

--- a/sql/sql_analyze_stmt.h
+++ b/sql/sql_analyze_stmt.h
@@ -49,22 +49,22 @@ class Exec_time_tracker
 {
 protected:
   ulonglong count;
-  ulonglong cycles;
+  ulonglong ns;
   ulonglong last_start;
 
-  void cycles_stop_tracking(THD *thd)
+  void ns_stop_tracking(THD *thd)
   {
-    ulonglong end= my_timer_cycles();
-    cycles += end - last_start;
+    ulonglong end= my_interval_timer();
+    ns += end - last_start;
     if (unlikely(end < last_start))
-      cycles += ULONGLONG_MAX;
+      ns += ULONGLONG_MAX;
 
     process_gap_time_tracker(thd, end);
     if (my_gap_tracker)
       attach_gap_time_tracker(thd, my_gap_tracker, end);
   }
 public:
-  Exec_time_tracker() : count(0), cycles(0), my_gap_tracker(NULL) {}
+  Exec_time_tracker() : count(0), ns(0), my_gap_tracker(NULL) {}
 
   /*
     The time spent between stop_tracking() call on this object and any
@@ -75,26 +75,25 @@ public:
   // interface for collecting time
   void start_tracking(THD *thd)
   {
-    last_start= my_timer_cycles();
+    last_start= my_interval_timer();
     process_gap_time_tracker(thd, last_start);
   }
 
   void stop_tracking(THD *thd)
   {
     count++;
-    cycles_stop_tracking(thd);
+    ns_stop_tracking(thd);
   }
 
   // interface for getting the time
   ulonglong get_loops() const { return count; }
   double get_time_ms() const
   {
-    // convert 'cycles' to milliseconds.
-    return 1000.0 * static_cast<double>(cycles) /
-      static_cast<double>(sys_timer_info.cycles.frequency);
+    // convert 'ns' to milliseconds.
+    return (double) ns / 1000.0;
   }
 
-  bool has_timed_statistics() const { return cycles > 0; }
+  bool has_timed_statistics() const { return ns > 0; }
 };
 
 
@@ -145,7 +144,7 @@ public:
   */
   void stop_tracking(THD *thd)
   {
-    cycles_stop_tracking(thd);
+    ns_stop_tracking(thd);
   }
 };
 
